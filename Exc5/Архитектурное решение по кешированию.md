# Архитектурное решение по кешированию

## Мотивация
1. Ускорение работы системы
2. Достижене SLA
3. Частичное/полное исключение проблемы потери заказов
4. Пользовательский опыт - Клиент, Оператор, Продавец

## Предлагаемое решение

Дисклеймер:
Не рассматриваем вопросы авторизации, т.к. здесь может быть отдельная стратегия

Для кэширования рассматриваем БД - с ними с наибольшей долей вероятности есть проблемы согласно изветным проблемам и показанной архитектуре:
1. ShopDB
2. MES db

### ShopDB
Основные используемые данные:
1. Список товаров - много чтений, мало записей
2. Список заказов - много записей, много чтений
3. Сисок клиентов - много чтений, мало записей

Здесь можно создать 2 отдельных кэша:
для списка товаров и списка клиентов cache-Aside как наиболее простой и не накладывает особых требований на отказоустойчивость кэша.
Инвалидация по времени
для списка заказов Write-Through, т.к. требуется актуальное сотсояние заказа как для клиента так и для Продавца, но так же допустимо остановиться на cache-Aside (при принятии риска задержки появленяи заказа).
Еще, как вариант, применить шардирование по клиентам.

Для товаров и заказов диаграммы созданы. Для клиентов аналогично товарам.
* ShopDB_orders.puml
* ShopDB_items.puml

Для CRM API кэш также строим cache-Aside, возможно использование кэш от Shop. Требуется учеть, что данные по заказам нужны по всем пользователям, по этой причине сам кэш скорее будет отличаться/будут использоватся другие индексы относительно Shop

Инвалидация:
1. для Товаров - временная, товары обновляются относительно редко при этом можно выбрать период инвалидации таким образом, чтобы кэш сбрасывался во время минимальной нагрузки
2. для Клиентов - Программная - когда с клиентом что-то происходит
3. для Заказов - Программная - по изменению статуса либо интервал времени (если допускаюся задержки в обновлении) - зависит Бизнес-процесса
4. Для Saller (CRM) кэш может отличаться - требуется уточнение Бизнес-процесса, но скорее это будет программная инвалидация.

### MES db
Основные используемые данные:
1. Список заказов
2. Назначение заказа на оператора
3. Статусы заказов
Много чтений, записи много но меньше чем чтений
Ограничение: требуется сихронизировать операторов, чтобы они видели взятые заказы и не пытались взять один и тот-же. Задержка не допустима.

Здесь применяем Write-Through т.к. требуется актуальное сотсояние заказа

Создана диаграмма
* MES_db.puml
  
Инвалидация:
1. программная, т.к. применен паттерн Write-Through
   
## Предлагаемое решение

Критерии отбора:
1. Возможности по реализации паттернов
2. Возможности по горизонтальному масштабированию
3. Стоимость решения
4. Требуемые ресурсы
5. Возможности / знания команды
6. Комьюнити
7. Поддержка системы

По пункту 5 выбран Redis, по остальным пунктам сравнение не проводилось.

Реализация: 
1. равзворачивание кэш
2. тестироввание (включая НТ)
3. Переключение сервисов на работу с КЭШ

## Диаграмма последовательности действий

### для Shop

* ShopDB_orders.puml
* ShopDB_items.puml

### для MES
* MES_db.puml
